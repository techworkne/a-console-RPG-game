@startuml game_architecture

skinparam linetype ortho
skinparam nodesep 40
skinparam ranksep 60
skinparam classFontSize 10

!define ABSTRACT abstract
!define ENUM enum

skinparam class {
  BackgroundColor White
  BorderColor Black
  ArrowColor Navy
}

skinparam package {
  BackgroundColor White
  BorderColor DarkGray
}

ABSTRACT class Entity {
  - health_ : int
  - damage_ : int  
  - x_ : size_t
  - y_ : size_t
  --
  + GetHealth() : int
  + GetDamage() : int
  + GetX() : size_t
  + GetY() : size_t
  + SetX(x: size_t) : void
  + SetY(y: size_t) : void
  + IsAlive() : bool
  + TakeDamage(damage: int) : void
  + GetType() : EntityType
  + getEntityTypeName(type: EntityType) : string
}
  
class Player {
  - score_ : int
  - lives_ : int
  - mana_ : int
  - combat_mode_ : CombatMode
  - stunned_ : bool
  - hand_ : PlayerHand
  --
  + GetScore() : int
  + GetLives() : int
  + GetMana() : int
  + IsStunned() : bool
  + GetCombatMode() : CombatMode
  + SwitchCombatMode() : void
  + getHand() : PlayerHand&
  + addSpellToHand(spell: unique_ptr<Spell>) : void
}
  
ABSTRACT class EnemyArchitecture {
  - spawn_interval_ : int
  - turns_since_spawn_ : int
  --
  + Update() : bool
  + CanSpawn() : bool
}

class Enemy {
  --
  + Update() : bool
}

class EnemyBuilding {
  --
}

class EnemyTower {
  - attack_radius_ : int
  - attack_cooldown_ : int
  - attack_spell_ : unique_ptr<DirectDamageSpell>
  --
  + AttackPlayerInRange(field: GameField&, player: Player*) : bool
  + GetAttackRadius() : int
}



ABSTRACT class Spell {
  # mana_cost_ : int
  --
  + cast(field: GameField&, caster: Entity*, target_x: size_t, target_y: size_t) : bool
  + getManaCost() : int
  + getName() : string
}

class DirectDamageSpell {
  - damage_ : int
  - enhanced_ : bool
  --
}

class AreaDamageSpell {
  - damage_ : int
  - range_ : int
  - enhanced_ : bool
  --
}

class TrapSpell {
  - trap_damage_ : int
  --
}


class GameField {
  - width_ : size_t
  - height_ : size_t
  - cells_ : vector<vector<FieldCell>>
  --
  + GetWidth() : size_t
  + GetHeight() : size_t
  + GetCell(x: size_t, y: size_t) : FieldCell*
  + PlaceEntity(x: size_t, y: size_t, entity: unique_ptr<Entity>) : bool
  + RemoveEntity(x: size_t, y: size_t) : void
}

class FieldCell {
  - type_ : FieldCellType
  - entity_ : unique_ptr<Entity>
  - trap_damage_ : int
  --
  + GetType() : FieldCellType
  + IsPassable() : bool
  + IsEmpty() : bool
  + GetEntity() : Entity*
  + SetEntity(entity: unique_ptr<Entity>) : void
  + ExtractEntity() : unique_ptr<Entity>
  + SetType(type: FieldCellType) : void
  + SetTrapDamage(damage: int) : void
  + GetTrapDamage() : int
  + RemoveTrap() : void
}


class GameState {
  - field_ : unique_ptr<GameField>
  - player_ : Player*
  --
  + GetField() : GameField*
  + GetPlayer() : Player*
  + SetPlayer(player: Player*) : void
  + IsGameOver() : bool
  + GetScore() : int
}

class GameLogic {
  - game_state_ : GameState
  - renderer_ : Renderer
  - input_handler_ : InputHandler
  - movement_system_ : unique_ptr<MovementEntity>
  --
  + Run() : void
  + ProcessTurn() : void
  + HandlePlayerInput(direction: Direction) : void
  + HandlePlayerAttack() : void
  + IsGameOver() : bool
  + GetScore() : int
}

class MovementEntity {
  - field_ : GameField*
  --
  + MoveEntity(from_x: size_t, from_y: size_t, to_x: size_t, to_y: size_t, player: Player*) : bool
  + MovePlayer(player: Player*, direction: Direction) : bool
  + MoveEnemyTowardsPlayer(enemy: Enemy*, player: Player*) : bool
  + CanAttackPlayer(enemy: Enemy*, player: Player*) : bool
  + AttackPlayer(enemy: Enemy*, player: Player*) : void
}

class PlayerHand {
  - spells_ : vector<unique_ptr<Spell>>
  - max_size_ : size_t
  --
  + getSpellCount() : size_t
  + getSpell(index: size_t) : Spell*
  + addSpell(spell: unique_ptr<Spell>) : bool
  + removeSpell(index: size_t) : void
}

class RewardSystem {
  --
  + GiveDestructionReward(entity_type: EntityType, player: Player*) : void
}

class InputHandler {
  --
  + GetCommand() : Command
  + GetAttackDirection() : Direction
}

class Renderer {
  --
  + Render(field: GameField&, player: Player*) : void
  + RenderControls() : void
  + RenderGameOver(score: int) : void
}

ENUM EntityType {
  kPlayer
  kEnemy
  kBuilding
  kTower
  kEmpty
}

ENUM FieldCellType {
  kNormal
  kImpassable
  kSlowdown
  kTrap
}

ENUM Direction {
  kUp
  kDown
  kLeft
  kRight
}

ENUM CombatMode {
  kMelee
  kRanged
}

ENUM Command {
  kMoveUp
  kMoveDown
  kMoveLeft
  kMoveRight
  kSwitchMode
  kAttack
  kCastSpell
  kSkipTurn
  kHelp
  kQuit
  kInvalid
}


Entity <|-- Player
Entity <|-- Enemy
Entity <|-- EnemyArchitecture
EnemyArchitecture <|-- EnemyBuilding
EnemyArchitecture <|-- EnemyTower

Spell <|-- DirectDamageSpell
Spell <|-- AreaDamageSpell
Spell <|-- TrapSpell


GameField *--  FieldCell
Player *-- PlayerHand
EnemyTower *-- DirectDamageSpell
PlayerHand *--  Spell
GameState *-- GameField


GameState o-- Player
MovementEntity o-- GameField

GameLogic --> GameState
GameLogic --> Renderer
GameLogic --> InputHandler
GameLogic --> MovementEntity
FieldCell --> Entity
MovementEntity --> Player
MovementEntity --> Enemy
EnemyTower --> Player
RewardSystem --> Player


GameLogic ..> EntityType
GameLogic ..> Direction
GameLogic ..> Command
InputHandler ..> Direction
InputHandler ..> Command
Renderer ..> GameField
Renderer ..> Player
MovementEntity ..> FieldCellType
MovementEntity ..> Direction
Player ..> CombatMode
AreaDamageSpell ..> EntityType
DirectDamageSpell ..> EntityType
TrapSpell ..> FieldCellType
RewardSystem ..> EntityType

@enduml